(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.bullshit = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

module.exports = ["曾经说过", "在不经意间这样说过", "说过一句著名的话", "曾经提到过", "说过一句富有哲理的话"];
},{}],2:[function(require,module,exports){
"use strict";

module.exports = ["爱迪生{前面垫话}，天才是百分之一的勤奋加百分之九十九的汗水。{后面垫话}", "查尔斯·史{前面垫话}，一个人几乎可以在任何他怀有无限热忱的事情上成功。{后面垫话}", "培根{前面垫话}，深窥自己的心，而后发觉一切的奇迹在你自己。{后面垫话}", "歌德{前面垫话}，流水在碰到底处时才会释放活力。{后面垫话}", "莎士比亚{前面垫话}，那脑袋里的智慧，就像打火石里的火花一样，不去打它是不肯出来的。{后面垫话}", "戴尔·卡耐基{前面垫话}，多数人都拥有自己不了解的能力和机会，都有可能做到未曾梦想的事情。{后面垫话}", "白哲特{前面垫话}，坚强的信念能赢得强者的心，并使他们变得更坚强。{后面垫话}", "伏尔泰{前面垫话}，不经巨大的困难，不会有伟大的事业。{后面垫话}", "富勒{前面垫话}，苦难磨炼一些人，也毁灭另一些人。{后面垫话}", "文森特·皮尔{前面垫话}，改变你的想法，你就改变了自己的世界。{后面垫话}", "拿破仑·希尔{前面垫话}，不要等待，时机永远不会恰到好处。{后面垫话}", "塞涅卡{前面垫话}，生命如同寓言，其价值不在与长短，而在与内容。{后面垫话}", "奥普拉·温弗瑞{前面垫话}，你相信什么，你就成为什么样的人。{后面垫话}", "吕凯特{前面垫话}，生命不可能有两次，但许多人连一次也不善于度过。{后面垫话}", "莎士比亚{前面垫话}，人的一生是短的，但如果卑劣地过这一生，就太长了。{后面垫话}", "笛卡儿{前面垫话}，我的努力求学没有得到别的好处，只不过是愈来愈发觉自己的无知。{后面垫话}", "左拉{前面垫话}，生活的道路一旦选定，就要勇敢地走到底，决不回头。{后面垫话}", "米歇潘{前面垫话}，生命是一条艰险的峡谷，只有勇敢的人才能通过。{后面垫话}", "吉姆·罗恩{前面垫话}，要么你主宰生活，要么你被生活主宰。{后面垫话}", "村上春树{前面垫话}，不幸可能成为通向幸福的桥梁。{后面垫话}", "海贝尔{前面垫话}，人生就是学校。在那里，与其说好的教师是幸福，不如说好的教师是不幸。{后面垫话}", "杰纳勒尔·乔治·S·巴顿{前面垫话}，接受挑战，就可以享受胜利的喜悦。{后面垫话}", "德谟克利特{前面垫话}，节制使快乐增加并使享受加强。{后面垫话}", "裴斯泰洛齐{前面垫话}，今天应做的事没有做，明天再早也是耽误了。{后面垫话}", "歌德{前面垫话}，决定一个人的一生，以及整个命运的，只是一瞬之间。{后面垫话}", "卡耐基{前面垫话}，一个不注意小事情的人，永远不会成就大事业。{后面垫话}", "卢梭{前面垫话}，浪费时间是一桩大罪过。{后面垫话}", "康德{前面垫话}，既然我已经踏上这条道路，那么，任何东西都不应妨碍我沿着这条路走下去。{后面垫话}", "克劳斯·莫瑟爵士{前面垫话}，教育需要花费钱，而无知也是一样。{后面垫话}", "伏尔泰{前面垫话}，坚持意志伟大的事业需要始终不渝的精神。{后面垫话}", "亚伯拉罕·林肯{前面垫话}，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。{后面垫话}", "韩非{前面垫话}，内外相应，言行相称。{后面垫话}", "富兰克林{前面垫话}，你热爱生命吗？那么别浪费时间，因为时间是组成生命的材料。{后面垫话}", "马尔顿{前面垫话}，坚强的信心，能使平凡的人做出惊人的事业。{后面垫话}", "笛卡儿{前面垫话}，读一切好书，就是和许多高尚的人谈话。{后面垫话}", "塞涅卡{前面垫话}，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。{后面垫话}", "易卜生{前面垫话}，伟大的事业，需要决心，能力，组织和责任感。{后面垫话}", "歌德{前面垫话}，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。{后面垫话}", "达尔文{前面垫话}，敢于浪费哪怕一个钟头时间的人，说明他还不懂得珍惜生命的全部价值。{后面垫话}", "有一个人{前面垫话}，感激每一个新的挑战，因为它会锻造你的意志和品格。{后面垫话}", "奥斯特洛夫斯基{前面垫话}，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。{后面垫话}", "苏轼{前面垫话}，古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。{后面垫话}", "王阳明{前面垫话}，故立志者，为学之心也；为学者，立志之事也。{后面垫话}", "歌德{前面垫话}，读一本好书，就如同和一个高尚的人在交谈。{后面垫话}", "乌申斯基{前面垫话}，学习是劳动，是充满思想的劳动。{后面垫话}", "别林斯基{前面垫话}，好的书籍是最贵重的珍宝。{后面垫话}", "富兰克林{前面垫话}，读书是易事，思索是难事，但两者缺一，便全无用处。{后面垫话}", "鲁巴金{前面垫话}，读书是在别人思想的帮助下，建立起自己的思想。{后面垫话}", "培根{前面垫话}，合理安排时间，就等于节约时间。{后面垫话}", "屠格涅夫{前面垫话}，你想成为幸福的人吗？但愿你首先学会吃得起苦。{后面垫话}", "莎士比亚{前面垫话}，抛弃时间的人，时间也抛弃他。{后面垫话}", "叔本华{前面垫话}，普通人只想到如何度过时间，有才能的人设法利用时间。{后面垫话}", "维博{前面垫话}，一次失败，只是证明我们成功的决心还够坚强。{后面垫话}", "拉罗什夫科{前面垫话}，取得成就时坚持不懈，要比遭到失败时顽强不屈更重要。{后面垫话}", "俾斯麦{前面垫话}，失败是坚忍的最后考验。{后面垫话}", "池田大作{前面垫话}，不要回避苦恼和困难，挺起身来向它挑战，进而克服它。{后面垫话}", "希腊的百姓{前面垫话}，最困难的事情就是认识自己。{后面垫话}", "黑塞的百姓{前面垫话}，有勇气承担命运这才是英雄好汉。{后面垫话}", "非洲的百姓{前面垫话}，最灵繁的人也看不见自己的背脊。{后面垫话}", "培根{前面垫话}，阅读使人充实，会谈使人敏捷，写作使人精确。{后面垫话}", "斯宾诺莎{前面垫话}，最大的骄傲于最大的自卑都表示心灵的最软弱无力。{后面垫话}", "西班牙的百姓{前面垫话}，自知之明是最难得的知识。{后面垫话}", "塞内加{前面垫话}，勇气通往天堂，怯懦通往地狱。{后面垫话}", "赫尔普斯{前面垫话}，有时候读书是一种巧妙地避开思考的方法。{后面垫话}", "笛卡儿{前面垫话}，阅读一切好书如同和过去最杰出的人谈话。{后面垫话}", "邓拓{前面垫话}，越是没有本领的就越加自命不凡。{后面垫话}", "爱尔兰{前面垫话}，越是无能的人，越喜欢挑剔别人的错儿。{后面垫话}", "老子{前面垫话}，知人者智，自知者明。胜人者有力，自胜者强。{后面垫话}", "歌德{前面垫话}，意志坚强的人能把世界放在手中像泥块一样任意揉捏。{后面垫话}", "迈克尔·F·斯特利{前面垫话}，最具挑战性的挑战莫过于提升自我。{后面垫话}", "爱迪生{前面垫话}，失败也是我需要的，它和成功对我一样有价值。{后面垫话}", "罗素·贝克{前面垫话}，一个人即使已登上顶峰，也仍要自强不息。{后面垫话}", "马云{前面垫话}，最大的挑战和突破在于用人，而用人最大的突破在于信任人。{后面垫话}", "雷锋{前面垫话}，自己活着，就是为了使别人过得更美好。{后面垫话}", "布尔沃{前面垫话}，要掌握书，莫被书掌握；要为生而读，莫为读而生。{后面垫话}", "培根{前面垫话}，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。{后面垫话}", "莫扎特{前面垫话}，谁和我一样用功，谁就会和我一样成功。{后面垫话}", "马克思{前面垫话}，一切节省，归根到底都归结为时间的节省。{后面垫话}", "莎士比亚{前面垫话}，意志命运往往背道而驰，决心到最后会全部推倒。{后面垫话}", "卡莱尔{前面垫话}，过去一切时代的精华尽在书中。{后面垫话}", "培根{前面垫话}，深窥自己的心，而后发觉一切的奇迹在你自己。{后面垫话}", "罗曼·罗兰{前面垫话}，只有把抱怨环境的心情，化为上进的力量，才是成功的保证。{后面垫话}", "孔子{前面垫话}，知之者不如好之者，好之者不如乐之者。{后面垫话}", "达·芬奇{前面垫话}，大胆和坚定的决心能够抵得上武器的精良。{后面垫话}", "叔本华{前面垫话}，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。{后面垫话}", "黑格尔{前面垫话}，只有永远躺在泥坑里的人，才不会再掉进坑里。{后面垫话}", "普列姆昌德{前面垫话}，希望的灯一旦熄灭，生活刹那间变成了一片黑暗。{后面垫话}", "维龙{前面垫话}，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。{后面垫话}", "郭沫若{前面垫话}，形成天才的决定因素应该是勤奋。{后面垫话}", "洛克{前面垫话}，学到很多东西的诀窍，就是一下子不要学很多。{后面垫话}", "西班牙的百姓{前面垫话}，自己的鞋子，自己知道紧在哪里。{后面垫话}", "拉罗什福科{前面垫话}，我们唯一不会改正的缺点是软弱。{后面垫话}", "亚伯拉罕·林肯{前面垫话}，我这个人走得很慢，但是我从不后退。{后面垫话}", "美华纳{前面垫话}，勿问成功的秘诀为何，且尽全力做你应该做的事吧。{后面垫话}", "俾斯麦{前面垫话}，对于不屈不挠的人来说，没有失败这回事。{后面垫话}", "阿卜·日·法拉兹{前面垫话}，学问是异常珍贵的东西，从任何源泉吸收都不可耻。{后面垫话}", "白哲特{前面垫话}，坚强的信念能赢得强者的心，并使他们变得更坚强。{后面垫话}", "查尔斯·史考伯{前面垫话}，一个人几乎可以在任何他怀有无限热忱的事情上成功。{后面垫话}", "贝多芬{前面垫话}，卓越的人一大优点是：在不利与艰难的遭遇里百折不饶。{后面垫话}", "莎士比亚{前面垫话}，本来无望的事，大胆尝试，往往能成功。{后面垫话}", "卡耐基{前面垫话}，我们若已接受最坏的，就再没有什么损失。{后面垫话}", "德国的百姓{前面垫话}，只有在人群中间，才能认识自己。{后面垫话}", "史美尔斯{前面垫话}，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。{后面垫话}", "冯学峰{前面垫话}，当一个人用工作去迎接光明，光明很快就会来照耀着他。{后面垫话}", "吉格·金克拉{前面垫话}，如果你能做梦，你就能实现它。{后面垫话}"];
},{}],3:[function(require,module,exports){
"use strict";

module.exports = ["这不禁令我深思。", "带着这句话，我们还要更加慎重的审视这个问题：", "这启发了我。", "我希望诸位也能好好地体会这句话。", "这句话语虽然很短，但令我浮想联翩。", "这句话看似简单，但其中的阴郁不禁让人深思。", "这句话把我们带到了一个新的维度去思考这个问题：", "这似乎解答了我的疑惑。"];
},{}],4:[function(require,module,exports){
"use strict";

module.exports = ["现在，解决{主题}的问题，是非常非常重要的。所以，", "我们不得不面对一个非常尴尬的事实，那就是，", "{主题}的发生，到底需要如何做到，不{主题}的发生，又会如何产生。", "如何引起{主题}的发生，{主题}又会如何产生？", "而这些并不是完全重要，更加重要的问题是，", "{主题}，到底应该如何实现。", "到底应该如何实现{主题}？", "带着这些问题，我们来审视一下{主题}。", "所谓{主题}，关键是{主题}需要如何写。", "我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。", "问题的关键究竟为何？", "{主题}因何而发生？", "每个人都不得不面对这些问题。在面对这种问题时，", "一般来讲，我们都必须务必慎重的考虑考虑。", "要想清楚，{主题}，到底是一种怎么样的存在。", "了解清楚{主题}到底是一种怎么样的存在，是解决一切问题的关键。", "就我个人来说，{主题}对我的意义，不能不说非常重大。", "本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。", "{主题}，发生了会如何，不发生又会如何。", "{主题}发生了会如何？不发生又会如何？", "在这种困难的抉择下，本人思来想去，寝食难安。", "生活中，若{主题}出现了，我们就不得不考虑它出现了的事实。", "这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。", "我们都知道，只要有意义，那么就必须慎重考虑。", "既然如此，", "那么，", "我认为，", "一般来说，", "总结的来说，", "无论如何，", "经过上述讨论，", "这样看来，", "从这个角度来看，", "我们不妨可以这样来想：", "这是不可避免的。", "可是，即使是这样，{主题}的出现仍然代表了一定的意义。", "{主题}似乎是一种巧合，但如果我们从一个更大的角度看待问题，这似乎是一种不可避免的事实。", "在这种不可避免的冲突下，我们必须解决这个问题。", "既然如此，", "对我个人而言，{主题}不仅仅是一个重大的事件，还可能会改变我的人生。"];
},{}],5:[function(require,module,exports){
"use strict";

module.exports = {
  "前面垫话": require("./前面垫话"),
  "后面垫话": require("./后面垫话"),
  "废话": require("./废话"),
  "名人名言": require("./名人名言"),
  "起段": "    ",
  "句号": "。"
};
},{"./前面垫话":1,"./名人名言":2,"./后面垫话":3,"./废话":4}],6:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// 常用类
// @author Dobby233Liu
var 常用 = /*#__PURE__*/function () {
  function 常用() {
    _classCallCheck(this, 常用);
  }

  _createClass(常用, null, [{
    key: "\u662F\u5426\u4EE5\u5B57\u7B26\u4E32\u7ED3\u675F",
    value: function 是否以字符串结束(字符串, 检测列表) {
      var _iterator = _createForOfIteratorHelper(检测列表),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var i = _step.value;

          if (字符串.endsWith(i)) {
            return true;
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return false;
    }
  }, {
    key: "\u80FD\u5426\u4EE5\u53E5\u53F7\u7ED3\u675F",
    value: function 能否以句号结束(段落) {
      return !this.是否以字符串结束(段落.trim(), ["。", ".", "：", ":", "？", "?", "！", "!", ",", "，", "、"]);
    }
  }, {
    key: "\u5408\u5E76\u5BF9\u8C61",
    value: function 合并对象(对象, 镜像) {
      var 合成 = 镜像;

      for (var i in 对象) {
        if (i != "__proto__") {
          合成[i] = 对象[i];
        }
      }

      return 合成;
    } // 分段系统实用函数

  }, {
    key: "\u80FD\u52A0\u6BB5",
    value: function 能加段(段) {
      return 段.indexOf("\n") > 0;
    }
  }, {
    key: "\u52A0\u6BB5",
    value: function 加段(列表, 段) {
      var 分 = 段.trimEnd().split("\n");

      for (var i in 分) {
        列表.push(分[i]);
      }

      return 列表;
    }
  }, {
    key: "\u6700\u540E\u4E00\u9879",
    value: function 最后一项(列表) {
      return 列表[列表.length - 1];
    }
  }, {
    key: "\u603B\u957F",
    value: function 总长(列表) {
      var 长 = 0;

      for (var i in 列表) {
        长 += 列表[i].length;
      }

      return 长;
    }
  }]);

  return 常用;
}();

module.exports = 常用;
},{}],7:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
 * libBullshit / 狗屁库
 * @author Dobby233Liu
 * @license Anti-996 License 1.0
 */
var 狗屁库 = /*#__PURE__*/function () {
  function 狗屁库() {
    _classCallCheck(this, 狗屁库);

    _defineProperty(this, "\u9ED8\u8BA4\u9009\u9879", {
      "有概率不添加后面垫话": false,
      "v3语法改进": true,
      "menzi11#175": true,
      "允许字典处理字符串": true,
      "返回段落列表": false,
      "能写少就写少": true
    });

    _defineProperty(this, "\u9ED8\u8BA4\u5B57\u5178", require("./dict/default/配置"));

    _defineProperty(this, "\u5E38\u7528", require("./常用"));

    _defineProperty(this, "\u968F\u673A", require("./随机常用"));

    _defineProperty(this, "generate", this.生成);
  }

  _createClass(狗屁库, [{
    key: "\u751F\u6210",
    value: function 生成() {
      var _this = this;

      var 主题 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "学生会退会";
      var 长度 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6000 * 主题.length;

      var _字典 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.默认字典;

      var _选项 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.默认选项;

      var 这是啥我也不知道 = function 这是啥我也不知道(主要的, 次要的) {
        return 主要的.length <= 0 ? _this.常用.最后一项(次要的) : 主要的;
      }; // 申密函数


      this.选项 = this.常用.合并对象(_选项, this.默认选项);
      this.字典 = this.常用.合并对象(_字典, this.默认字典);
      if (this.选项["允许字典处理字符串"] && this.字典["主题处理"] && typeof this.字典["主题处理"] == "function") 主题 = this.字典["主题处理"](主题, this.字典, this.选项, this.常用, this.随机);
      this.起段 = this.字典.起段;
      this.前面垫话 = this.字典.前面垫话;
      this.后面垫话 = this.字典.后面垫话;

      if (this.选项["menzi11#175"]) {
        this.下一句前面垫话 = this.随机.洗牌遍历(this.字典.前面垫话);
        this.下一句后面垫话 = this.随机.洗牌遍历(this.字典.后面垫话);
      }

      this.下一句名人名言 = this.随机.洗牌遍历(this.字典.名人名言);
      this.下一句废话 = this.随机.洗牌遍历(this.字典.废话); // ------------

      var 文章 = [];
      var 起段 = this.起段.replace(/\{主题\}/g, 主题);
      var 段缓冲 = "";
      var 类型 = "忽略";

      while (this.常用.总长(文章) < 长度 && (!this.选项["能写少就写少"] || this.常用.总长(文章) + 段缓冲.length < 长度) || this.选项.v3语法改进 && this.常用.是否以字符串结束(这是啥我也不知道(段缓冲, 文章).trim(), ["：", ":", ",", "，"])) {
        var 缓冲 = "";
        类型 = "忽略";
        var 分支 = this.随机.取随机数(100);

        if (分支 < 5 && (!this.选项.v3语法改进 || !(段缓冲.length <= 0 || this.常用.是否以字符串结束(段缓冲.trim(), [",", "，", "、"])))) {
          if (!this.选项.v3语法改进 || this.常用.能否以句号结束(段缓冲.trim())) 缓冲 = this.字典.句号.replace(/\{主题\}/g, 主题);
          类型 = "新行";
        } else if (分支 < 20) {
          var 言 = this.下一句名人名言.next().value;
          言 = 言.replace(/\{前面垫话\}/g, (this.选项["menzi11#175"] ? this.下一句前面垫话.next().value : this.随机.瞎选一个(this.前面垫话)).replace(/\{主题\}/g, 主题));

          if (!this.选项.有概率不添加后面垫话 || this.随机.取随机数(10) != 1) {
            言 = 言.replace(/\{后面垫话\}/g, (this.选项["menzi11#175"] ? this.下一句后面垫话.next().value : this.随机.瞎选一个(this.后面垫话)).replace(/\{主题\}/g, 主题));
          } else {
            言 = 言.replace(/\{后面垫话\}/g, "");
          }

          缓冲 = 言;
          类型 = "名人名言";
        } else {
          缓冲 = this.下一句废话.next().value.replace(/\{主题\}/g, 主题);
          类型 = "废话";
        } // else 缓冲 = "";
        // hack


        if (this.选项["允许字典处理字符串"] && this.字典["缓冲处理"] && typeof this.字典["缓冲处理"] == "function") {
          段缓冲 += this.字典["缓冲处理"](缓冲, this.字典, this.选项, this.常用, this.随机, 类型);
        } else 段缓冲 += 缓冲;

        if (this.常用.能加段(段缓冲) || 类型 == "新行") {
          文章 = this.常用.加段(文章, 起段 + 段缓冲);
          段缓冲 = "";
        }
      }

      if (段缓冲 != "") 文章 = this.常用.加段(文章, 起段 + 段缓冲);
      段缓冲 = "";
      if (this.选项["允许字典处理字符串"] && this.字典["文章处理"] && typeof this.字典["文章处理"] == "function") 文章 = this.字典["文章处理"](文章, this.字典, this.选项, this.常用, this.随机);
      if (!this.选项["返回段落列表"]) 文章 = 文章.join("\n");
      return 文章;
    }
  }]);

  return 狗屁库;
}();

module.exports = 狗屁库;
},{"./dict/default/配置":5,"./常用":6,"./随机常用":8}],8:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var 随机常用 = /*#__PURE__*/function () {
  function 随机常用() {
    _classCallCheck(this, 随机常用);
  }

  _createClass(随机常用, null, [{
    key: "\u53D6\u968F\u673A\u5C0F\u6570",
    value: function 取随机小数() {
      return Math.random();
    }
    /**
     * @param {Array} _数组
     *
     * https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
     */

  }, {
    key: "\u6D17\u724C",
    value: function 洗牌(_数组) {
      var 数组 = _数组.slice();

      for (var i = 数组.length - 1; i > 0; i--) {
        var j = Math.floor(this.取随机小数() * (i + 1));
        var _ref = [数组[j], 数组[i]];
        数组[i] = _ref[0];
        数组[j] = _ref[1];
      }

      return 数组;
    }
  }, {
    key: "\u778E\u9009\u4E00\u4E2A",
    value: function 瞎选一个(数组) {
      var max = 数组.length;
      var min = 0;
      return 数组[Math.floor(this.取随机小数() * (max - min)) + min];
    }
  }, {
    key: "\u6D17\u724C\u904D\u5386",
    value: function 洗牌遍历(数组) {
      var 重复度 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var 次数组 = [];

      for (var ii = 0; ii < 重复度; ii++) {
        次数组 = 次数组.concat(数组);
      }

      次数组 = this.洗牌(次数组);
      return {
        next: function (随机, _数组) {
          var i = 0;

          var 数组 = _数组.slice();

          return function __next__() {
            var ret = 数组[i++];

            if (!(i < 次数组.length)) {
              数组 = 随机.洗牌(数组);
              i = 0;
            }

            return {
              value: ret,
              done: false
            };
          };
        }(this, 次数组)
      };
    }
  }, {
    key: "\u53D6\u968F\u673A\u6570",
    value: function 取随机数(最大数) {
      return Math.floor(this.取随机小数() * 最大数);
    }
  }]);

  return 随机常用;
}();

module.exports = 随机常用;
},{}]},{},[7])(7)
});
